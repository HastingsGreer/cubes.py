
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Twiddle</title>
    <style>
        #canvas {
            margin: 0 auto;
            display: block;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/pyodide/v0.27.2/full/pyodide.js"></script>
</head>
<body>

    <script type="text/javascript">
        async function main(){
          let pyodide = await loadPyodide();
          await pyodide.loadPackage(["pygame-ce"], { checkIntegrity: false })
          await pyodide.loadPackage(["numpy"], { checkIntegrity: false })
          await pyodide.loadPackage(["scipy"], { checkIntegrity: false })

          canvas = document.getElementById("canvas");
          pyodide.canvas.setCanvas2D(canvas);

          pyodide.runPythonAsync(`
import numpy as np
import random
import sys
import scipy
import asyncio


import pygame

pygame.init()


display_matrix = []
colors = []

order = 2

slices = [1]

size = order + 2
for i in range(size):
    for j in range(size):
        for k in range(size):
            count = 0
            color = []
            if i == 0:
                color = [255, 0, 0]
                count += 1
            if i == size - 1:
                color = [255, 255, 0]
                count += 1
            if j == 0:
                color = [0, 255, 0]
                count += 1
            if j == size - 1:
                color = [0, 255, 255]
                count += 1
            if k == 0:
                color = [0, 0, 255]
                count += 1
            if k == size - 1:
                color = [255, 0, 255]
                count += 1

            if count == 1:
                display_matrix.append([i, j, k])
                colors.append(color)
display_matrix = 200.5 + 60 * np.array(display_matrix)

WHITE = (255, 255, 255)
BLACK = (0, 0, 0)


def solve(D):
    N = len(D)
    eye = np.eye(N)

    def test(D, prefix):
        D = D - np.mean(D, axis=0, keepdims=True)
        if (
            np.abs(np.linalg.norm(D[len(prefix) - 1]) - np.linalg.norm(D[prefix[-1]]))
            > 0.001
        ):
            return False
        if len(prefix) != len(set(prefix)):
            return False
        A = eye[prefix]
        targ = eye[: len(prefix)]
        transformed_A = A @ D
        transformed_identity = targ @ D
        Q = (
            np.linalg.inv(transformed_A.T @ transformed_A + np.eye(3) * 0.000001)
            @ transformed_A.T
            @ transformed_identity
        )

        if np.abs(np.linalg.det(Q) + 1) < 0.001:
            return False
        if len(prefix) == N + 3:
            if np.all(A @ A == eye):
                return False
            if np.all(A @ A @ A == eye):
                return False
        return (
            np.max(np.abs(transformed_A.T - Q @ transformed_identity.T)) < 0.01
        ).item()

    def recursive_solve(D, prefix, out):
        if len(prefix) == N:
            out.append(eye[prefix])
            return
        for i in range(N):
            oo = prefix + [i]
            if test(D, oo):
                recursive_solve(D, oo, out)

    out = []
    print("solving")
    recursive_solve(D, [], out)
    print("solved")
    return out


rot = solve(display_matrix)
moves = []


def maybe_add(arr):
    if not any(np.all(arr == u) for u in moves):
        moves.append(arr)


for s in slices:
    slice_size = order * order + s * 4 * order

    head = display_matrix[:(slice_size)]
    rot_face = solve(head)
    template = np.eye(order * order * 6)
    template[:slice_size, :slice_size] = rot_face[1]

    for m in rot:
        maybe_add(m @ template @ m.T)
        maybe_add(m @ template.T @ m.T)

for m in rot[1:]:
    if np.all(m @ m == np.eye(len(display_matrix))):
        continue
    maybe_add(m)
    maybe_add(m.T)


frames_per_turn = 8

moves = [scipy.linalg.expm(1 / frames_per_turn * scipy.linalg.logm(x)) for x in moves]


async def main():
    state = np.eye(order * order * 6)
    dejitter = np.eye(3) + np.ones((3, 3)) * .001
    toMove = []

    for i in range(0):
        j = random.randint(0, len(moves) - 1)
        toMove += [j] * frames_per_turn

    """
      Contains the game variables and loop
      """
    screen = pygame.display.set_mode((600, 500))
    clock = pygame.Clock()
    pygame.display.set_caption("Twiddle")

    running = True
    while running:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            if event.type == pygame.KEYDOWN:
                for i, letter in enumerate("1234qwerasdfzxcv5678tyuighjkbnm,"):
                    if event.unicode == letter:
                        if i < len(moves):
                            toMove += [i] * frames_per_turn
                if event.unicode == "p":
                    toMove = []
                    state = np.eye(order * order * 6)
        if len(toMove):
            state = state @ moves[toMove[0]]
            toMove = toMove[1:]
        screen.fill(WHITE)

        cube = state.real @ display_matrix @ dejitter

        cube = reversed(sorted(list(zip(map(tuple, cube), map(list, colors)))))

        for i, ((z, x, y), color) in enumerate(cube):
            center = (x - 0.4 * z, y - 0.4 * z)
            pygame.draw.circle(screen, BLACK, center, 50)
            pygame.draw.circle(screen, color, center, 40)


        pygame.display.flip()
        clock.tick(60)
        await asyncio.sleep(0)

    pygame.quit()
main()

  `)
        }

        main()
      </script>

        <canvas id="canvas"></canvas>
	<p>A twisty puzzle! press 1234qwerasdfzxcv to make moves. Implemented in python, to see if python is the web language of the future.</p>
	<p>She's a bit slow, give her a minute to load. It's (a) in python, and (b) computing what a pyraminx is from scratch because caching would require some sort of build system, at which point I'd just write my website in C </p>
	<p>This website is just a single html file- open view source to see how it works</p>
	<a href=/index.html>Back</a>

</body>
</html>
